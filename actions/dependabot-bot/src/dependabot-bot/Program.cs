if (args is { Length: 0 } || args[0] is not string path)
{
    WriteLine("Must specify a repo root directory as input");
    return 1;
}

string destinationFilePath = args is { Length: 2 }
    && !string.IsNullOrWhiteSpace(args[1])
    ? args[1]
    : $".github{Path.AltDirectorySeparatorChar}dependabot.yml";

/*
Dependabot encountered the following error when parsing your .github/dependabot.yml:

The property '#/updates' had more items than the allowed 200
Please update the config file to conform with Dependabot's specification. 
*/
const int UpdateNodeLimit = 200;
var updateNodeCount = 0;

StringBuilder buffer = new();

// yaml top-matter
string topMatter = """
    # Generated by dependabot-bot.
    # https://github.com/dotnet/docs-tools/tree/main/actions/dependabot-bot
    version: 2
    updates:
    """;

buffer.WriteLineToBufferAndOutput(topMatter, false);

// Entry to update GitHub Actions
string gitHubActions = """
    - package-ecosystem: "github-actions" # Core GitHub Actions
      directory: "/"
      schedule:
        interval: "weekly"
        day: "wednesday"
      open-pull-requests-limit: 10
  """;

buffer.WriteLineToBufferAndOutput(gitHubActions, updateNodeCount++ >= UpdateNodeLimit);

/* Generate the following pattern for each project file:

  Note: Wednesday was chosen for quick response to .NET patch Tuesday updates

- package-ecosystem: ""nuget""
  directory: ""/"" #projectfilename
  schedule:
      interval: ""weekly""
      day: ""wednesday""
  open-pull-requests-limit: 5
  groups:
    # Group .NET updates together
    dotnet:
      patterns:
        - "*" # Prefer a single PR
*/

Dictionary<string, string[]> packageIgnore = await GetPackagesInfoAsync();

string dotnetDir = $"**/{Path.AltDirectorySeparatorChar}.dotnet";

var discoveryService = AddAndGetDiscoveryService();

var result = await discoveryService.DiscoverAllAsync(path);

foreach (var solution in result.Solutions.OrderBy(static sln => sln.FullPath))
{
    string file = solution.FullPath;
    string filename = Path.GetFileName(file);
    string? parentDir = Path.GetDirectoryName(file);
    string relativeDir = parentDir?[path.Length..].Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar) ?? Path.AltDirectorySeparatorChar.ToString();

    // Use groups:
    // https://docs.github.com/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file#groups
    buffer.WriteLineToBufferAndOutput($"""
              - package-ecosystem: "nuget"
                directory: "{relativeDir}" #{filename}
                schedule:
                  interval: "weekly"
                  day: "wednesday"
                open-pull-requests-limit: 5
                groups:
                  # Group .NET updates together for solutions.
                  dotnet:
                    patterns:
                      - "*" # Prefer a single PR per solution update.
            """,
        UpdateNodeLimit == updateNodeCount++);
}

foreach (var fileInfo in result.StandaloneProjects.Select(static p => new FileInfo(p.FullPath)).OrderBy(f => f.FullName))
{
    string file = fileInfo.FullName;
    string filename = fileInfo.Name;
    string? parentDir = Path.GetDirectoryName(file);
    string relativeDir = parentDir?[path.Length..].Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar) ?? Path.AltDirectorySeparatorChar.ToString();
    string? targetFramework = null;
    bool match = false;
    List<PackageIgnoreMapping> mappings = [];
    foreach (string content in File.ReadLines(file))
    {
        if (targetFramework is null && TryGetTargetFramework(content, out targetFramework))
        {
        }

        if (PackageReferenceVersionRegex().IsMatch(content))
        {
            match = true;

            if (TryGetPackageName(content, out string? packageName) &&
                packageIgnore.TryGetValue($"{packageName}_{targetFramework}", out string[]? ignore))
            {
                mappings.Add(new(packageName, ignore));
            }

            break;
        }
    }

    if (match is false)
    {
        continue;
    }

    // Use groups:
    // https://docs.github.com/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file#groups
    buffer.WriteLineToBufferAndOutput($"""
              - package-ecosystem: "nuget"
                directory: "{relativeDir}" #{filename}
                schedule:
                  interval: "weekly"
                  day: "wednesday"
                open-pull-requests-limit: 5
                groups:
                  # Group .NET updates together for projects.
                  dotnet:
                    patterns:
                      - "*" # Prefer a single PR per project update.
            """,
        updateNodeCount++ >= UpdateNodeLimit);

    if (mappings.Count is 0)
    {
        continue;
    }

    /* Format:
    ignore:
     - dependency-name: "Microsoft.AspNetCore.Mvc.NewtonsoftJson"
       versions: ["5.*"]        
    */

    buffer.WriteLineToBufferAndOutput("    ignore:", false);

    foreach (PackageIgnoreMapping mapping in mappings)
    {
        buffer.WriteLineToBufferAndOutput($"""
                      - dependency-name: ""{mapping.PackageName}""
                       versions: {PrintArrayAsYaml(mapping.Ignore)}
                """, false);
    }
}

if (buffer.Length > topMatter.Length)
{
    var contents = buffer.ToString();
    await File.WriteAllTextAsync(destinationFilePath, contents);
}

return 0;

static async Task<Dictionary<string, string[]>> GetPackagesInfoAsync()
{
    var packages = await GetPackageInfoFromRawGitHubUrlAsync();
    return packages switch
    {
        null => throw new IOException("Could not download packages information"),
        _ => packages.Packages
                .SelectMany(package => package.Mapping.Select(mapping => (Key: $"{package.Name}_{mapping.TargetFramework}", Value: mapping.Ignore)))
                .ToDictionary(_ => _.Key, _ => _.Value)
    };
}

static async Task<PackageInfoSet?> GetPackageInfoFromRawGitHubUrlAsync()
{
    const string RawGitHubUrl = """
        https://raw.githubusercontent.com/dotnet/docs-tools/main/actions/dependabot-bot/packages-ignore.json
        """;

    using HttpClient client = new();
    var packageInfo = await client.GetFromJsonAsync<PackageInfoSet>(RawGitHubUrl);
    return packageInfo;
}

static string PrintArrayAsYaml(string[] array)
{
    StringBuilder buffer = new();
    buffer.Append('[');
    for (int i = 0; i < array.Length; i++)
    {
        buffer.Append($@"""{array[i]}""");

        if (i + 1 < array.Length)
        {
            buffer.Append(", ");
        }
    }
    buffer.Append(']');

    return buffer.ToString();
}

file record PackageInfoSet(PackageInfo[] Packages);

file readonly record struct PackageInfo(string Name, PackageTargetFrameworkIgnoreMapping[] Mapping);
file readonly record struct PackageTargetFrameworkIgnoreMapping(string TargetFramework, string[] Ignore);
file readonly record struct PackageIgnoreMapping(string PackageName, string[] Ignore);
